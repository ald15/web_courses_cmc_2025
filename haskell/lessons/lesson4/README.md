# Пояснительная бригада

1. Типы-контейнеры и контекстные типы
Maybe a — контейнер, представлющий либо отсутствие значения (Nothing), либо значение типа a (Just a).

Either e a — контейнер для результата, где Left e обычно означает ошибку или альтернативное значение типа e, а Right a — успешный результат типа a.

2. Класс Functor
Позволяет преобразовать содержимое контейнера, не «раскрывая» его:

haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
fmap f (Just x) = Just (f x)

fmap для Either e сохраняет Left e без изменений, применяет f только к Right x.

3. Класс Applicative
Расширяет Functor, добавляя возможность «применять» функции, заключённые в контейнер, к значениям в других контейнерах:

haskell
class Functor f => Applicative f where
  pure  :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
pure помещает произвольное значение в минимальный контекст (например, Just, [], Right).

<*> позволяет комбинировать контекстные функции и контекстные аргументы, распространять «эффекты» или «контекст» (ошибок, пустоты и т. д.).

4. Класс Monoid
Обобщает понятие «сложения» с нейтральным элементом:

haskell
class Monoid m where
  mempty  :: m           -- нейтральный элемент
  mappend :: m -> m -> m -- операция «сложения»
  (<>)     :: m -> m -> m
  (<>) = mappend
Законы:

Лево- и право-нейтральность: mempty <> x = x, x <> mempty = x.

Ассоциативность: (x <> y) <> z = x <> (y <> z).

Примеры
Список [] как моноид с объединением (++) и mempty = [].

All (лог. конъюнкция), Any (лог. дизъюнкция):

mempty :: All — истина; mappend = &&.

mempty :: Any — ложь; mappend = ||.

Sum a и Product a для чисел через +/*.

Endo a для композиции функций: mempty = id, mappend = (.).